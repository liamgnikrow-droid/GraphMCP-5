import os
import sys

# Add parent directory to path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

try:
    from db_config import get_driver, WORKSPACE_ROOT
    from graph_sync import GraphSync
except ImportError:
    from Tools.db_config import get_driver, WORKSPACE_ROOT
    from Tools.graph_sync import GraphSync

def clean_duplicates():
    driver = get_driver()
    sync = GraphSync()
    
    print("ðŸš€ Starting Global Deduplication (Title-based)...")
    
    # 1. Fetch all semantic nodes
    query = """
    MATCH (n) 
    WHERE NOT labels(n)[0] IN ['Action', 'Constraint', 'NodeType']
    RETURN n.uid as uid, n.title as title, labels(n)[0] as type
    """
    records, _, _ = driver.execute_query(query, database_="neo4j")
    
    # 2. Group by type and title (case insensitive)
    groups = {}
    for r in records:
        if not r['title'] or not r['uid']: continue
        
        key = (r['type'], r['title'].lower().strip())
        if key not in groups: groups[key] = []
        groups[key].append(r)
        
    total_cleaned = 0
    
    for (ntype, title), nodes in groups.items():
        if len(nodes) > 1:
            print(f"\nðŸ” Group: [:{ntype}] '{title}'")
            
            # Selection Strategy:
            # 1. Prefer nodes that have existing files.
            # 2. Prefer shorter/cleaner UIDs (if applicable).
            # 3. Use Neo4j to check which one has more relationships.
            
            scored_nodes = []
            for n in nodes:
                uid = n['uid']
                score = 0
                
                # Check disk
                fpath = sync.get_file_path(uid, ntype)
                if os.path.exists(fpath):
                    score += 100
                    # Check file size/content? (Maybe too much)
                
                # Check relationships
                rel_query = "MATCH (n {uid: $uid})-[r]-() RETURN count(r) as c"
                res, _, _ = driver.execute_query(rel_query, {"uid": uid}, database_="neo4j")
                score += res[0]['c']
                
                # Penalty for long "md_" prefixed UIDs often generated by buggy mappers
                if "md_" in uid:
                    score -= 5
                
                scored_nodes.append((score, n))
            
            # Sort by score descending
            scored_nodes.sort(key=lambda x: x[0], reverse=True)
            
            winner = scored_nodes[0][1]
            losers = [sn[1] for sn in scored_nodes[1:]]
            
            print(f"   ðŸ† Winner: {winner['uid']} (Score: {scored_nodes[0][0]})")
            
            for loser in losers:
                loser_uid = loser['uid']
                print(f"   ðŸ—‘ï¸  Merging Loser: {loser_uid}")
                
                # A. Transfer Outgoing Relationships
                # We use apoc if available, but for now pure Cypher MERGE logic
                # Note: We skip RELATIONSHIPS if they already exist from winner to target
                
                # 1. Outgoing
                driver.execute_query(f"""
                MATCH (l {{uid: $loser}})-[r]->(target)
                MATCH (w {{uid: $winner}})
                WHERE l <> target AND w <> target
                CALL apoc.merge.relationship(w, type(r), {{}}, properties(r), target) YIELD rel
                RETURN count(rel)
                """, {"loser": loser_uid, "winner": winner['uid']}, database_="neo4j")
                
                # 2. Incoming
                driver.execute_query(f"""
                MATCH (source)-[r]->(l {{uid: $loser}})
                MATCH (w {{uid: $winner}})
                WHERE l <> source AND w <> source
                CALL apoc.merge.relationship(source, type(r), {{}}, properties(r), w) YIELD rel
                RETURN count(rel)
                """, {"loser": loser_uid, "winner": winner['uid']}, database_="neo4j")
                
                # B. Content Transfer (if loser has content and winner doesn't)
                content_query = """
                MATCH (l {uid: $loser}), (w {uid: $winner})
                SET w.content = CASE WHEN w.content IS NULL OR w.content = '' THEN l.content ELSE w.content END,
                    w.description = CASE WHEN w.description IS NULL OR w.description = '' THEN l.description ELSE w.description END
                """
                driver.execute_query(content_query, {"loser": loser_uid, "winner": winner['uid']}, database_="neo4j")

                # C. Delete Loser
                driver.execute_query("MATCH (n {uid: $uid}) DETACH DELETE n", {"uid": loser_uid}, database_="neo4j")
                
                # D. Delete File
                fpath = sync.get_file_path(loser_uid, ntype)
                if os.path.exists(fpath):
                    os.remove(fpath)
                    print(f"      âœ… Deleted file: {fpath}")
                
                total_cleaned += 1

    print(f"\nâœ¨ Deduplication complete. Removed {total_cleaned} redundant nodes.")
    
    # 3. Final synchronization to ensurewinner files are updated with new links
    print("ðŸ”„ Running final synchronization...")
    sync.sync_all()

if __name__ == "__main__":
    clean_duplicates()
