# Предложение по Архитектуре: Параметрическая Валидация (Iron Dome 2.0)

**Дата:** 2026-02-04
**Статус:** Draft / Proposal
**Цель:** Перенос логики бизнес-правил из кода инструментов (`server.py`) в декларативную схему Мета-Графа для автоматической валидации.

## 1. Проблема (The "Blind Middleware" Problem)

Текущая реализация `Iron Dome Middleware` проверяет права доступа только по имени инструмента.

```python
# Текущая логика
if has_permission(current_node_type, tool_name):
    execute_tool()
```

Это создает уязвимость для "полиморфных" инструментов, поведение которых радикально меняется от аргументов.
**Пример:** `create_concept(type="Spec")` и `create_concept(type="Requirement")` — это один и тот же `tool_name`, но совершенно разные права доступа в нашей иерархии.

Сейчас мы вынуждены писать `if`-проверки внутри кода инструмента (`tool_create_concept`), дублируя логику графа в коде (`Impl hardcoding`). Это нарушает принцип "Graph as Source of Truth".

## 2. Предлагаемое Решение: Параметрическая Валидация

Необходимо научить Middleware фильтровать вызовы не только по имени функции, но и по значениям критических аргументов, сопоставляя их со свойствами узлов `Action` в графе.

### 2.1. Изменение Схемы Мета-Графа

Узлы `Action` должны явно содержать значения параметров, которые они разрешают.

**Было:**
```cypher
(:Action {tool_name: 'create_concept'}) // Один общий Action на все случаи
```

**Станет (Дробление Actions):**
```cypher
// Действие: Создание Спецификации
(:Action {
    uid: 'ACT-create_spec',
    tool_name: 'create_concept',
    constraint_arg_type: 'Spec' // <-- Ключевое ограничение
})

// Действие: Создание Требования
(:Action {
    uid: 'ACT-create_req',
    tool_name: 'create_concept',
    constraint_arg_type: 'Requirement'
})
```

В графе связи `CAN_PERFORM` будут вести к конкретным, узким действиям:
*   `Idea -[:CAN_PERFORM]-> ACT-create_spec`
*   `Spec -[:CAN_PERFORM]-> ACT-create_req`
*   *(Связи `Idea -> ACT-create_req` НЕ БУДЕТ)*

### 2.2. Изменение Middleware (`server.py`)

Функция `check_action_permission` должна динамически строить запрос, проверяя соответствие аргументов вызова свойствам Action.

**Псевдокод алгоритма:**

1.  Агент вызывает: `create_concept(title="...", type="Requirement")`
2.  Middleware извлекает аргументы.
3.  Выполняет Cypher-запрос:

```cypher
MATCH (agent_loc:NodeType)-[:CAN_PERFORM]->(act:Action)
WHERE act.tool_name = 'create_concept'
  // Динамическая фильтрация:
  // Если у Action задано ограничение на аргумент 'type', 
  // то переданный аргумент 'type' ОБЯЗАН совпадать.
  AND (
      act.constraint_arg_type IS NULL 
      OR act.constraint_arg_type = $args.type
  )
RETURN count(act) > 0
```

4.  **Результат:**
    *   Если Агент сидит на `Idea`, запрос вернет `0` (так как связи с Act, где `type='Requirement'`, нет).
    *   Доступ запрещен Middleware **автоматически**.
    *   Код инструмента (`def tool_create_concept`) даже не начнет выполняться.

## 3. Преимущества

1.  **Zero-Code Rules:** Чтобы запретить или разрешить создание определенного типа узлов, нам не нужно править Python-код. Мы просто меняем связи в графе Neo4j.
2.  **Надежность:** Невозможно "забыть" проверку в коде (как это случилось у нас), потому что проверка выполняется ядром системы для всех инструментов одинаково.
3.  **Самодокументируемость:** Команда `explain_physics` сможет точно сказать: "Ты не можешь создать Требование здесь", а не просто "Ты не можешь использовать create_concept" (что было бы неправдой, так как Spec создавать можно).

## 4. План Реализации (Roadmap)

1.  **Refactor Bootstrap:** Обновить `bootstrap_metagraph.py`, добавив свойства `constraint_arg_*` в узлы Action.
2.  **Refactor Middleware:** Обновить логику проверки прав в `server.py` для учета аргументов.
3.  **Cleanup:** Удалить ручные проверки (`if/else`) из функций инструментов.

---
*Документ предназначен для аналитического использования и планирования будущих спринтов.*
